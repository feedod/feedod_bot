<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="robots" content="noindex, nofollow">
  <title>Чат</title>
  <!-- Подключение Tailwind CSS через CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @keyframes blink {
      0%, 100% { opacity: 0.2; }
      50% { opacity: 1; }
    }
  </style>
  <!-- Подключение Telegram Mini App SDK через CDN (опционально) -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <!-- Подключение Axios через CDN -->
  <script src="https://unpkg.com/axios@1.6.7/dist/axios.min.js"></script>
  <!-- Подключение Mithril через CDN -->
  <script src="https://unpkg.com/mithril@2.2.2/mithril.min.js"></script>
</head>
<body>
  <div id="app"></div>

  <script type="module">
    const ChatModel = {
      API_URL: 'https://jsonplaceholder.typicode.com/posts', // Пример API для тестирования
      messages: [],
      inputText: '',
      isSending: false,
      lastMessageTime: 0,
      messageQueue: [],
      userId: 'anonymous', // Заглушка для userId
      config: {
        debounceTime: 300,
        maxMessagesPerMinute: 20,
        sanitizeRegex: /[<>&"']/g,
      },

      sanitizeInput(text) {
        return text.replace(this.config.sanitizeRegex, '').trim().slice(0, 500);
      },

      async fetchAPI(method, data = null) {
        try {
          const response = await axios({
            method,
            url: this.API_URL,
            headers: {
              'Content-Type': 'application/json',
              'X-Telegram-User': this.userId,
            },
            data,
          });
          return response.data;
        } catch (error) {
          throw new Error(`Axios error: ${error.response?.status || error.message}`);
        }
      },

      debounce(fn, delay) {
        let timeout;
        return (...args) => {
          clearTimeout(timeout);
          timeout = setTimeout(() => fn(...args), delay);
        };
      },

      rateLimit() {
        const now = Date.now();
        if (now - this.lastMessageTime < 60_000 / this.config.maxMessagesPerMinute) return false;
        this.lastMessageTime = now;
        return true;
      },
    };

    const ChatController = {
      initTelegram() {
        if (window.Telegram?.WebApp) {
          const tg = window.Telegram.WebApp;
          tg.ready();
          tg.expand();
          ChatModel.userId = tg.initDataUnsafe?.user?.id ?? 'anonymous';
          document.body.style.backgroundColor = tg.themeParams.bg_color ?? '#ffffff';
          tg.BackButton.show();
          tg.onEvent('backButtonClicked', () => tg.close());
        } else {
          console.log('Telegram.WebApp не доступен. Работаем в браузере.');
          ChatModel.userId = 'browser-user'; // Заглушка для браузера
        }
      },

      async fetchMessages() {
        try {
          ChatModel.isSending = true;
          m.redraw();
          const data = await ChatModel.fetchAPI('get');
          ChatModel.messages = data.slice(0, 10).map((post) => ({ // Пример обработки данных
            text: post.title,
            isUser: post.userId === ChatModel.userId,
            isSystem: false,
          }));
        } catch (error) {
          ChatModel.messages.push({ text: 'Ошибка загрузки', isSystem: true });
          console.error(error);
        } finally {
          ChatModel.isSending = false;
          m.redraw();
          this.scrollToBottom();
        }
      },

      async sendMessage(text) {
        try {
          ChatModel.isSending = true;
          await ChatModel.fetchAPI('post', { text });
          await this.fetchMessages();
          ChatModel.inputText = '';
        } catch (error) {
          ChatModel.messages.push({ text: 'Ошибка отправки', isSystem: true });
          console.error(error);
        } finally {
          ChatModel.isSending = false;
          m.redraw();
        }
      },

      startQueueProcessor() {
        setInterval(async () => {
          if (ChatModel.messageQueue.length && !ChatModel.isSending) {
            const text = ChatModel.messageQueue.shift();
            await this.sendMessage(text);
          }
        }, 100);
      },

      scrollToBottom() {
        const messagesEl = document.querySelector('#messages');
        if (messagesEl) {
          messagesEl.scrollTo({ top: messagesEl.scrollHeight, behavior: 'smooth' });
        }
      },

      handleInput(event) {
        ChatModel.inputText = event.target.value;
        event.target.style.height = 'auto';
        event.target.style.height = `${Math.min(event.target.scrollHeight, 120)}px`;
      },

      handleSend: ChatModel.debounce(async function () {
        const text = ChatModel.sanitizeInput(ChatModel.inputText);
        if (!text || ChatModel.isSending || !ChatModel.rateLimit()) return;
        ChatModel.messageQueue.push(text);
      }, ChatModel.config.debounceTime),
    };

    const ChatView = {
      oninit() {
        ChatController.initTelegram();
        ChatController.fetchMessages();
        ChatController.startQueueProcessor();
      },

      view() {
        return m('div', {
          class: 'w-full max-w-[800px] mx-auto min-h-screen grid grid-rows-[1fr_auto_auto] border-l-2 border-r-2 border-black bg-white',
        }, [
          m('div#messages', {
            class: 'p-5 overflow-y-auto max-h-[calc(100vh-120px)] border-b-2 border-black',
            'aria-live': 'polite',
          }, ChatModel.messages.map(msg =>
            m('div', {
              class: [
                'mb-3 p-3 border-2 border-black border-l-6 text-base break-words',
                msg.isUser ? 'bg-gray-600 text-white ml-[10%]' :
                msg.isSystem ? 'bg-white text-center border-dashed italic' :
                'bg-gray-200',
              ].join(' '),
            }, msg.text)
          )),
          m('div#typing-indicator', {
            class: `p-2 bg-white border-b-2 border-black ${ChatModel.isSending ? 'block' : 'hidden'}`,
          }, [
            m('span', { class: 'inline-block w-2 h-2 mx-[5px] bg-black animate-[blink_1.2s_infinite]' }),
            m('span', { class: 'inline-block w-2 h-2 mx-[5px] bg-black animate-[blink_1.2s_infinite_0.2s]' }),
            m('span', { class: 'inline-block w-2 h-2 mx-[5px] bg-black animate-[blink_1.2s_infinite_0.4s]' }),
          ]),
          m('div', {
            class: 'grid grid-cols-[1fr_auto] gap-2 p-2 bg-white border-b-2 border-black',
          }, [
            m('textarea#message-input', {
              class: 'p-2 border-2 border-black bg-white font-mono text-base resize-none min-h-[40px] max-h-[120px] focus:outline-none focus:bg-gray-100',
              placeholder: 'Сообщение',
              value: ChatModel.inputText,
              maxlength: 500,
              'aria-label': 'Ввод сообщения',
              oninput: ChatController.handleInput,
              onkeypress: (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                  e.preventDefault();
                  ChatController.handleSend();
                }
              },
            }),
            m('button#send-button', {
              class: 'p-[10px_20px] bg-black text-white border-2 border-black font-mono text-base cursor-pointer hover:-translate-x-0.5 hover:-translate-y-0.5 disabled:opacity-50 disabled:cursor-not-allowed transition-transform',
              disabled: ChatModel.isSending,
              'aria-label': 'Отправить сообщение',
              onclick: ChatController.handleSend,
            }, '→'),
          ]),
        ]);
      },
    };

    m.mount(document.getElementById('app'), ChatView);
  </script>
</body>
</html>
